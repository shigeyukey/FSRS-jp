# はじめに

Bin(区間､階級)ごとの二乗平均平方根誤差（RMSE（bins））は、FSRSや他の間隔反復アルゴリズムがリコールの確率（R）をどれだけ正確に予測できるかを測定するために設計された指標です。

ベンチマーク実験では、RMSE（bins）指標が時々不正に利用されることがあると判明しました。そのため、アルゴリズムが人工的に低いRMSE（bins）を取得するのを防ぐために、binning方法を修正しました。

## RMSE（bins）の旧計算方法

1\) Rの予測値をbinにグループ化します。例えば、0.8から0.9の間の予測をbin 1にグループ化します：

    Bin 1（予測値）：[0.81, 0.82, 0.83, 0.84, 0.85, 0.86]

2\) 各binに対して、レビューの実際の結果を記録します。Again = 0。Hard/Good/Easy = 1。

    Bin 1（実際の結果）：[0, 1, 1, 1, 1, 1]

3\) Bin内のすべての予測値の平均を計算します。

    Bin 1の平均（予測値） = mean([0.81, 0.82, 0.83, 0.84, 0.85, 0.86]) = 0.835

4\) すべての実際の結果の平均を計算します。

    Bin 1の平均（実際の結果） = mean([0, 1, 1, 1, 1, 1]) = 0.833

5\) 予測値の平均と実際のレビュー結果の平均の二乗差を計算します。

6\) 各binに対してステップ2-5を繰り返します。binの数は任意です。各binのレビュー数は重み付けに使用されます。

7\) 次の式を使用して最終値を計算します：

$$RMSE(bins)=\sqrt\frac{\sum\limits\_{i=1}^{n} w\_{i} \cdot ({\overline{R}\_{i}}\_{\text{predicted}}-{\overline{R}\_{i}}\_{\text{measured}})^2}{\sum\limits_{i=1}^{n} w\_{i}}$$

ここで、
- $\overline{R}\_{\text{predicted}}$ は特定のbin内のリコールの予測確率の平均、
- $\overline{R}\_{\text{measured}}$ は特定のbin内の実際のレビュー結果の平均、
- $w$ は特定のbin内のレビュー数、
- $n$ はbinの数です。

## どのように操作(cheated)されるか

もしアルゴリズムが各レビューでデータセットの平均保持率と正確に等しい一定の数値を予測すると、RMSE（bins）は0になります。これは極端な例ですが、露骨に操作しないアルゴリズムでも、予測の分散を減らすことで微妙に操作することができます。

左のキャリブレーショングラフは操作しないアルゴリズムのもので、右のキャリブレーショングラフは操作するアルゴリズムのものです。

![311506217-948f32d0-a1f9-4b4e-b0be-0964105bb284](https://github.com/open-spaced-repetition/fsrs4anki/assets/83031600/338d8d81-9389-4d91-9cca-5b9b6551d548)


## RMSE（bins）の新しい計算方法

主な違いはbinning方法です。予測されたRに基づいてアルゴリズムの予測とレビューの結果をグループ化する代わりに、新しい方法では、間隔の長さ、レビューの回数、およびラプスの回数（ユーザーが「Again」を押した回数）の3つの特徴に基づいてグループ化します。これら3つの特徴の値は、この指標のために設計された式を使用して丸められます。これらの式は任意であり、調整可能です。その後、丸められた値に基づいてレビューがbinにグループ化されます。例えば、間隔の長さが100、レビューの回数が7、ラプスの回数が0のレビューと、間隔の長さが101、レビューの回数が7、ラプスの回数が0のレビューは、同じbinに分類されます。以前は、予測されたRの値がどのbinに入るかはその分布によって決定されていました。binningは現在、予測されたRの分布に依存しません。

以下は丸め関数の疑似コードです：

```py
delta_t = round(2.48 * power(2.57, floor(log(x)/log(2.57))), 2)

n_reviews = round(1.52 * power(1.58, floor(log(x)/log(1.58))), 0)

n_lapses = round(1.4 * power(1.48, floor(log(x)/log(1.48))), 0) if x != 0 else 0
```
